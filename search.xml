<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS中如何确定数据类型</title>
      <link href="/posts/635ac944.html"/>
      <url>/posts/635ac944.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -JavaStript -Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件通信之透传(attributes)</title>
      <link href="/posts/ba9b56.html"/>
      <url>/posts/ba9b56.html</url>
      
        <content type="html"><![CDATA[<h2 id="组件通信之透传-attributes-md"><a href="#组件通信之透传-attributes-md" class="headerlink" title="组件通信之透传(attributes).md"></a>组件通信之透传(attributes).md</h2><p>Vant和element-UI是我们在vue中经常使用的两个组件库，为了提高复用，我们经常会封装一些组件。</p><p>这里我基于vant-navbar封装了一个导航组件，并在父组件中引入使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//--------  子组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;van-nav-bar</span><br><span class="line">      title=&quot;标题&quot;</span><br><span class="line">      left-text=&quot;返回&quot;</span><br><span class="line">      left-arrow</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//-------- 父组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nav-bar&gt;&lt;/nav-bar&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import NavBar from &quot;./navBar.vue&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="父子传值"><a href="#父子传值" class="headerlink" title="父子传值"></a>父子传值</h4><p>正常情况下，我们是通过父传子来实现组件的差异化的(父组件传入子组件需要的变量，子组件接收并使用)</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//--------  子组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;van-nav-bar</span><br><span class="line">      + :title=&quot;title&quot;</span><br><span class="line">      left-text=&quot;返回&quot;</span><br><span class="line">      left-arrow</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line"><span class="addition">+defineProps&lt;&#123; title: string &#125;&gt;()</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------- 父组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line"><span class="addition">+ &lt;nav-bar title=&quot;我是test&quot;&gt;&lt;/nav-bar&gt;</span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="诡异的问题"><a href="#诡异的问题" class="headerlink" title="诡异的问题"></a>诡异的问题</h4><p>但是我们在父组件中传入一个和van-nav-bar属性同名的变量(这里用title举例)<br>，并且子组件中不去接受这个变量，神奇的事情就发生了，子组件并没有接收这个变量但是子组件中的van-nav-bar的标题变为了我们传入的这个值</p><p><img src="https://pengyuhang.com/attributes-1.png" alt="非常诡异"></p><p>经过我的苦思冥想(Google)，终于让我在<a href="https://cn.vuejs.org/guide/components/attrs.html#fallthrough-attributes">Vue官方文档</a>找到了这诡异现象的原因。</p><p>相关解释如下：</p><p><code>透传 Attributes：指的是传递给一个组件，却没有被该组件声明为props或emits的 attribute 或者  v-on 事件监听器。最常见的例子就是 class、style 和id。当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。</code></p><p>简单来说就是父组件传入一个值，但是子组件没有声明props来接受这个值，这个值会被渲染到子组件的根元素上。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>到此为止，破案了。我封装的组件根元素刚好是van-nav-bar而且父传子，子没有接受，所以父组件传入的title就被渲染到了根元素&lt;<br>van-nav-bar/&gt;身上===&gt; <van-nav-bar title='父组件传入的值'/>，所以navbar的标题就被顺势改了。</p><p>当然要避免这种现象的发生也很简单：</p><p>1.子组件去接收这个变量(正经人谁父子传值，不去接收啊。。。。)</p><p>2.在van-nav-bar外边再包一个标签，起到隔离的作用(这样van-nav-bar就不是根元素了)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端多数据优化之虚拟列表</title>
      <link href="/posts/6a969c28.html"/>
      <url>/posts/6a969c28.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端多数据优化之虚拟列表"><a href="#前端多数据优化之虚拟列表" class="headerlink" title="前端多数据优化之虚拟列表"></a>前端多数据优化之虚拟列表</h2><p>我是test</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端多数据优化之分片渲染</title>
      <link href="/posts/edb56c4b.html"/>
      <url>/posts/edb56c4b.html</url>
      
        <content type="html"><![CDATA[<h1 id="前端多数据优化之分片渲染"><a href="#前端多数据优化之分片渲染" class="headerlink" title="前端多数据优化之分片渲染"></a>前端多数据优化之分片渲染</h1><pre><code>    如果后端给一次你返回10万条数据你会怎么做？    如果直接渲染的话很大概率上会导致浏览器卡顿甚至停止运行</code></pre><p><img src="https://pengyuhang.com/error.png" alt="服务器崩溃"></p><p>所以就有了分片渲染这一方案</p><h3 id="分片渲染"><a href="#分片渲染" class="headerlink" title="分片渲染"></a>分片渲染</h3><p>分片渲染简单的说就是利用宏任务队列的特点,当上一个宏任务执行完下一个宏任务才会执行,这里可以使用定时器来达到分片渲染的目的</p><h4 id="第一步："><a href="#第一步：" class="headerlink" title="第一步："></a>第一步：</h4><p>采用for循环来达到获取10万条数据的目的，将数据存储在realList中，同时我们准备一个存储分片数据的列表renderList，并通过v-for指令渲染到页面中(<br>当然此时renderList并没有数据，页面也就不会渲染)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item,i) in renderList&quot; :key=&quot;i&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  nane: &#x27;testIndex&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      realList: [],</span><br><span class="line">      renderList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">      this.realList.push(`我是第$&#123;i + 1&#125;条数据`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h4><p>准备一个方法来达到分割原始数据的目的</p><p>使用数组方法slice来分割数组，并声明一个中间变量list来存储分割后的数据，每次固定分割50个数据(自定)</p><p>若第一次分割的数据是索引值0—50的，下一次分割我们就要从索引值50开始100结束(即开始索引和结束索引都加50==&gt;结束时的索引)<br>，这里我们为了方便，把slice的第两个参数设置为 this.start + this.end，下次分割时只需要修改初始索引值即可</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line"><span class="addition">+    start: 0,</span></span><br><span class="line"><span class="addition">+    end: 50,</span></span><br><span class="line">  realList: [],</span><br><span class="line">  renderList: []</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  load() &#123;</span><br><span class="line">    let list = this.realList.slice(this.start, this.start + this.end)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>为了达到多次重复分割的目的，我们使用利用递归的方式(即在这个方法中再次调用这个方法)，我们需要判断一下原始数据中是不是还存在我们没有分割到的数据</p><p>在定时器中，向renderList push我们分割好的数组(避免二级数组的出现，需要使用…展开运算符)<br>，当这次分割好的50个数组push完后，我们需要分割下50个数组，把start的值改为this.start + this.end()后再次调用我们定义的或者方法</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">load() &#123;</span><br><span class="line">let list = this.realList.slice(this.start, this.start + this.end)</span><br><span class="line">if (list &amp;&amp; list.length &gt; 0) &#123;//当数组存在且又未分割到的数据时再往下执行</span><br><span class="line"><span class="addition">+        setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="addition">+        this.renderList.push(...list)</span></span><br><span class="line"><span class="addition">+        this.start = this.start + this.end</span></span><br><span class="line"><span class="addition">+        this.load()</span></span><br><span class="line"><span class="addition">+       &#125;, 500)</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="最后在页面加载时去调用这个方法"><a href="#最后在页面加载时去调用这个方法" class="headerlink" title="最后在页面加载时去调用这个方法"></a>最后在页面加载时去调用这个方法</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    this.realList.push(`我是第$&#123;i + 1&#125;条数据`)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  this.load()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们再渲染大数据的时候就不会出现浏览器卡死的情况了</p><p>上文介绍的只是最简单的一种分片渲染，只是把全部数据分片后再全部渲染到页面，还有更高级的应用，如：每次只渲染一定的数据，当检测到触底后再加载下一部分之类的。。。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
