<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx的安装与配置</title>
      <link href="/posts/484e051.html"/>
      <url>/posts/484e051.html</url>
      
        <content type="html"><![CDATA[<p>当你有一个页面和一台服务器，可以借助nginx来把你的网页部署到服务器上，让别人可以通过互联网来访问你的网站</p><h3 id="nginx的安装-cents-OS"><a href="#nginx的安装-cents-OS" class="headerlink" title="nginx的安装(cents OS)"></a>nginx的安装(cents OS)</h3><p>在终端输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure><p>如果出现 <code>Is this ok [y/d/N]:  </code>输入y回车即可</p><p>当控制台出现Complete!代表nginx安装完成。在控制台输入nginx来启动nginx服务</p><p>在浏览器输入服务器的ip地址如果显示如下信息就代表nginx配置成功</p><p><img src="https://image.pengyuhang.com/%E6%88%90%E5%8A%9F.png" alt="配置成功"></p><h3 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h3><p>cd 到nginx目录下的配置文件来修改nginx的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx  # 进入nginx的根目录</span><br><span class="line">ls # 可以通过ls命令来查看目录下的文件</span><br><span class="line">vi nginx.conf  # 进入nginx的配置文件</span><br></pre></td></tr></table></figure><p>在配置文件中输入i来进行编辑</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">-user nginx; </span></span><br><span class="line"><span class="addition">+user root; #将用户名改为root</span></span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log /var/log/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.</span><br><span class="line">include /usr/share/nginx/modules/*.conf;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line"></span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 4096;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    # Load modular configuration files from the /etc/nginx/conf.d directory.</span><br><span class="line">    # See http://nginx.org/en/docs/ngx_core_module.html#include</span><br><span class="line">    # for more information.</span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        listen       [::]:80;</span><br><span class="line"><span class="deletion">-       server_name  _;</span></span><br><span class="line"><span class="addition">+    server_name  xxx.xxx.xxx; # 将server_name改为服务器的id或者你解析后的域名</span></span><br><span class="line"><span class="addition">+       root         /usr/share/nginx/html; # 此项更改为你存放网页的根目录</span></span><br><span class="line"><span class="addition">+       index        index.html;   # 根目录中网站主页的文件名</span></span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        error_page 404 /404.html;</span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成以上配置后在终端中输入nginx -s reload来重载服务,再次在浏览器中输入你的网址，即可查看你部署到服务器的网站了</p><h4 id="Cents-OS上nginx的常用命令"><a href="#Cents-OS上nginx的常用命令" class="headerlink" title="Cents OS上nginx的常用命令"></a>Cents OS上nginx的常用命令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">nginx # 启动nginx服务</span><br><span class="line"></span><br><span class="line">nginx -V # 查看nginx版本</span><br><span class="line"></span><br><span class="line">nginx -t # 验证nginx的配置文件</span><br><span class="line"></span><br><span class="line">nginx -s reopen       # 重启 Nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload       # 重载nginx</span><br><span class="line"></span><br><span class="line">nginx -s stop         # 强制停止 nginx 服务</span><br><span class="line"></span><br><span class="line">nginx -s quit         # 优雅地停止 nginx 服务（即处理完所有请求后再停止服务）</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中如何确定数据类型</title>
      <link href="/posts/635ac944.html"/>
      <url>/posts/635ac944.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS中如何确定数据类型"><a href="#JS中如何确定数据类型" class="headerlink" title="JS中如何确定数据类型"></a>JS中如何确定数据类型</h1><p>说起数据类型js中的typeof和instanceof都可以实现检测数据类型的作用，那他们有什么区别呢</p><h2 id="一、typeof"><a href="#一、typeof" class="headerlink" title="一、typeof"></a>一、typeof</h2><p><code>typeof</code> 操作符返回一个字符串，表示未经计算的操作数的类型</p><p>使用方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> operand</span><br><span class="line"><span class="title function_">typeof</span>(operand)</span><br></pre></td></tr></table></figure><p><code>operand</code>表示对象或原始值的表达式，其类型将被返回</p><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="title class_">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="variable language_">console</span>.<span class="property">log</span> <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure><p>从上面例子，前6个都是基础数据类型。虽然<code>typeof null</code>为<code>object</code>，但这只是<code> JavaScript</code> 存在的一个悠久 <code>Bug</code>，不代表<code>null </code>就是引用数据类型，并且<code>null </code>本身也不是对象</p><p>所以，<code>null </code>在 <code>typeof </code>之后返回的是有问题的结果，不能作为判断<code>null</code>的方法。如果你需要在 <code>if</code> 语句中判断是否为 <code>null</code>，直接通过<code>===null</code>来判断就好</p><p>同时，可以发现引用类型数据，用<code>typeof</code>来判断的话，除了<code>function</code>会被识别出来之外，其余的都输出<code>object</code></p><p>如果我们想要判断一个变量是否存在，可以使用<code>typeof</code>：(不能使用<code>if(a)</code>， 若<code>a</code>未声明，则报错)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> a != <span class="string">&#x27;undefined&#x27;</span>)&#123;</span><br><span class="line">    <span class="comment">//变量存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、instanceof"><a href="#二、instanceof" class="headerlink" title="二、instanceof"></a>二、instanceof</h2><p><code>instanceof</code> 运算符用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</p><p>使用如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><p><code>object</code>为实例对象，<code>constructor</code>为构造函数</p><p>构造函数通过<code>new</code>可以实例对象，<code>instanceof </code>能判断这个对象是否是之前那个构造函数生成的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构建函数</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Car</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> benz = <span class="keyword">new</span> <span class="title class_">Car</span>()</span><br><span class="line">benz <span class="keyword">instanceof</span> <span class="title class_">Car</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> car = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">car <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="title class_">String</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>关于<code>instanceof</code>的实现原理，可以参考下面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里先用typeof来判断基础数据类型，如果是，直接返回false</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> left !== <span class="string">&#x27;object&#x27;</span> || left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// getProtypeOf是Object对象自带的API，能够拿到参数的原型对象</span></span><br><span class="line">    <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(left);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;                  </span><br><span class="line">        <span class="keyword">if</span>(proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(proto === right.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到相同原型对象，返回true</span></span><br><span class="line">        proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(proto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是顺着原型链去找，直到找到相同的原型对象，返回<code>true</code>，否则为<code>false</code></p><h2 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h2><p><code>typeof</code>与<code>instanceof</code>都是判断数据类型的方法，区别如下：</p><ul><li><code>typeof</code>会返回一个变量的基本类型，<code>instanceof</code>返回的是一个布尔值</li><li><code>instanceof</code> 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型</li><li>而<code> typeof</code> 也存在弊端，它虽然可以判断基础数据类型（<code>null</code> 除外），但是引用数据类型中，除了<code> function</code> 类型以外，其他的也无法判断</li></ul><p>可以看到，上述两种方法都有弊端，并不能满足所有场景的需求</p><h2 id="四、toString"><a href="#四、toString" class="headerlink" title="四、toString"></a>四、toString</h2><p>如果需要通用检测数据类型，可以采用<code>Object.prototype.toString</code>，调用该方法，统一返回格式<code>“[object Xxx]” </code>的字符串</p><p>如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">toString</span>(&#123;&#125;)       <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(&#123;&#125;)  <span class="comment">// 同上结果，加上call也ok</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">1</span>)    <span class="comment">// &quot;[object Number]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;1&#x27;</span>)  <span class="comment">// &quot;[object String]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)  <span class="comment">// &quot;[object Boolean]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)  <span class="comment">// &quot;[object Function]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">null</span>)   <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="regexp">/123/g</span>)    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">//&quot;[object Date]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])       <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">document</span>)  <span class="comment">//&quot;[object HTMLDocument]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="variable language_">window</span>)   <span class="comment">//&quot;[object Window]&quot;</span></span><br></pre></td></tr></table></figure><p>了解了<code>toString</code>的基本用法，下面就实现一个全局通用的数据类型判断方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> type  = <span class="keyword">typeof</span> obj;</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&quot;object&quot;</span>) &#123;    <span class="comment">// 先进行typeof判断，如果是基础数据类型，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">replace</span>(<span class="regexp">/^\[object (\S+)\]$/</span>, <span class="string">&#x27;$1&#x27;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getType</span>([])     <span class="comment">// &quot;Array&quot; typeof []是object，因此toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="string">&#x27;123&#x27;</span>)  <span class="comment">// &quot;string&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="variable language_">window</span>) <span class="comment">// &quot;Window&quot; toString返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">null</span>)   <span class="comment">// &quot;Null&quot;首字母大写，typeof null是object，需toString来判断</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="literal">undefined</span>)   <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>()            <span class="comment">// &quot;undefined&quot; typeof 直接返回</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;) <span class="comment">// &quot;function&quot; typeof能判断，因此首字母小写</span></span><br><span class="line"><span class="title function_">getType</span>(<span class="regexp">/123/g</span>)      <span class="comment">//&quot;RegExp&quot; toString返回</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaStript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件通信之透传(attributes)</title>
      <link href="/posts/ba9b56.html"/>
      <url>/posts/ba9b56.html</url>
      
        <content type="html"><![CDATA[<h2 id="组件通信之透传-attributes-md"><a href="#组件通信之透传-attributes-md" class="headerlink" title="组件通信之透传(attributes).md"></a>组件通信之透传(attributes).md</h2><p>Vant和element-UI是我们在vue中经常使用的两个组件库，为了提高复用，我们经常会封装一些组件。</p><p>这里我基于vant-navbar封装了一个导航组件，并在父组件中引入使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//--------  子组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;van-nav-bar</span><br><span class="line">      title=&quot;标题&quot;</span><br><span class="line">      left-text=&quot;返回&quot;</span><br><span class="line">      left-arrow</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">//-------- 父组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;nav-bar&gt;&lt;/nav-bar&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line">import NavBar from &quot;./navBar.vue&quot;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="父子传值"><a href="#父子传值" class="headerlink" title="父子传值"></a>父子传值</h4><p>正常情况下，我们是通过父传子来实现组件的差异化的(父组件传入子组件需要的变量，子组件接收并使用)</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//--------  子组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;van-nav-bar</span><br><span class="line">      + :title=&quot;title&quot;</span><br><span class="line">      left-text=&quot;返回&quot;</span><br><span class="line">      left-arrow</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup lang=&quot;ts&quot;&gt;</span><br><span class="line"><span class="addition">+defineProps&lt;&#123; title: string &#125;&gt;()</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-------- 父组件 ---------</span><br><span class="line">&lt;template&gt;</span><br><span class="line"><span class="addition">+ &lt;nav-bar title=&quot;我是test&quot;&gt;&lt;/nav-bar&gt;</span></span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="诡异的问题"><a href="#诡异的问题" class="headerlink" title="诡异的问题"></a>诡异的问题</h4><p>但是我们在父组件中传入一个和van-nav-bar属性同名的变量(这里用title举例)<br>，并且子组件中不去接受这个变量，神奇的事情就发生了，子组件并没有接收这个变量但是子组件中的van-nav-bar的标题变为了我们传入的这个值</p><p><img src="https://image.pengyuhang.com/%E9%80%8F%E4%BC%A0.png" alt="非常诡异"></p><p>经过我的苦思冥想(Google)，终于让我在<a href="https://cn.vuejs.org/guide/components/attrs.html#fallthrough-attributes">Vue官方文档</a>找到了这诡异现象的原因。</p><p>相关解释如下：</p><p><code>透传 Attributes：指的是传递给一个组件，却没有被该组件声明为props或emits的 attribute 或者  v-on 事件监听器。最常见的例子就是 class、style 和id。当一个组件以单个元素为根作渲染时，透传的 attribute 会自动被添加到根元素上。</code></p><p>简单来说就是父组件传入一个值，但是子组件没有声明props来接受这个值，这个值会被渲染到子组件的根元素上。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>到此为止，破案了。我封装的组件根元素刚好是van-nav-bar而且父传子，子没有接受，所以父组件传入的title就被渲染到了根元素&lt;<br>van-nav-bar/&gt;身上===&gt; <van-nav-bar title='父组件传入的值'/>，所以navbar的标题就被顺势改了。</p><p>当然要避免这种现象的发生也很简单：</p><p>1.子组件去接收这个变量(正经人谁父子传值，不去接收啊。。。。)</p><p>2.在van-nav-bar外边再包一个标签，起到隔离的作用(这样van-nav-bar就不是根元素了)</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端多数据优化之虚拟列表</title>
      <link href="/posts/6a969c28.html"/>
      <url>/posts/6a969c28.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端多数据优化之虚拟列表"><a href="#前端多数据优化之虚拟列表" class="headerlink" title="前端多数据优化之虚拟列表"></a>前端多数据优化之虚拟列表</h2><p>上一次我们介绍了一种多数据优化方案：分片渲染，那么除此之外还有没有其他的方案，答案是当然有，这就要请出今天的主角——虚拟列表</p><h3 id="什么是虚拟列表"><a href="#什么是虚拟列表" class="headerlink" title="什么是虚拟列表"></a>什么是虚拟列表</h3><p>虚拟列表简单的来说就是只固定渲染可视区域内的内容，可视区域外的内容都是空的，滚动条由空白盒子撑起来，相比于分片渲染及普通渲染虚拟列表的性能要更加少(渲染的内容大大减少)</p><p><img src="https://image.pengyuhang.com/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8%E5%AF%B9%E6%AF%94.png" alt="虚拟列表对比普通渲染"></p><h3 id="虚拟列表的实现"><a href="#虚拟列表的实现" class="headerlink" title="虚拟列表的实现"></a>虚拟列表的实现</h3><h4 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h4><p><img src="https://image.pengyuhang.com/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/%E6%9C%80%E7%BB%88%E6%95%88%E6%9E%9C.gif" alt="效果"></p><h4 id="准备容器及变量"><a href="#准备容器及变量" class="headerlink" title="准备容器及变量"></a>准备容器及变量</h4><p>虚拟列表的渲染数据和分片渲染的数据都是由真实数据(为了简便这里同样使用for循环生成)截取获得的，同样我们需要准备两个变量来存储截取的开始位置和截取的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div  class=&quot;virtualList&quot; &gt; // 虚拟列表的容器</span><br><span class="line">      // 空白盒子 为了撑起滚动条</span><br><span class="line">      &lt;div&gt;&lt;/div&gt; </span><br><span class="line">      // 可视区域的盒子</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      start: 0, // 截取开始位置</span><br><span class="line">      size: 20,// 截取的大小</span><br><span class="line">      height: 30, // 每个渲染项的高度</span><br><span class="line">      realList: [] // 真实数据</span><br><span class="line">      scrollTop: 0 // 渲染盒子的scrollTop</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">      this.realList.push(`我是第$&#123;i + 1&#125;条数据`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="准备渲染数据及渲染"><a href="#准备渲染数据及渲染" class="headerlink" title="准备渲染数据及渲染"></a>准备渲染数据及渲染</h4><p>这里使用计算属性来计算真实渲染所需的列表，空白盒子的高度是根据真实数据来计算得到的(真实数据条数*渲染中每个盒子的高度),渲染盒子的高度由渲染条数和渲染中每个盒子的高度来决定的</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"><span class="addition">+  &lt;div class=&quot;box&quot; :style=&quot;&#123;&#x27;height&#x27;:this.size * this.height + &#x27;px&#x27;&#125;&quot;&gt;</span></span><br><span class="line"><span class="addition">+    &lt;div  class=&quot;virtualList&quot; :style=&quot;&#123;&#x27;height&#x27;:this.size * this.height + &#x27;px&#x27;&#125;&quot;&gt; // 虚拟列表的容器</span></span><br><span class="line">      // 空白盒子 为了撑起滚动条</span><br><span class="line"><span class="addition">+      &lt;div :style=&quot;&#123;&#x27;height&#x27; : realList.length*height +&#x27;px&#x27;&#125;&quot;&gt;&lt;/div&gt; </span></span><br><span class="line">      // 可视区域的盒子</span><br><span class="line">      &lt;div class=&quot;content&quot;&gt;</span><br><span class="line"><span class="addition">+       &lt;div v-for=&quot;(item,i) in renderList&quot; :key=&quot;i&quot; :style=&quot;&#123;&#x27;height&#x27;:height+&#x27;px&#x27;&#125;&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;</span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">   return &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;...&#125;,</span><br><span class="line"><span class="addition">+  computed: &#123;</span></span><br><span class="line"><span class="addition">+   renderList() &#123;</span></span><br><span class="line"><span class="addition">+      return this.realList.slice(this.start, this.start + this.size)</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="css样式"><a href="#css样式" class="headerlink" title="css样式"></a>css样式</h4><p>虚拟列表的盒子是通过绝对定位来固定到可视区域的，这里需要给外层盒子加一个关键属性才能显示出滚动条来(让其固定在一个区域，值占用浏览器显示位置的一部分，而不是撑开浏览器)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">600px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.virtualList</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: auto; // <span class="attribute">overflow</span>设置为auto或者scroll</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.content</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p><img src="https://image.pengyuhang.com/%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8/overflow%E5%8C%BA%E5%88%AB.png" alt="overflow"></p><h4 id="根据盒子滚动的距离来设置绝对定位的top以及数据截取的起始位置"><a href="#根据盒子滚动的距离来设置绝对定位的top以及数据截取的起始位置" class="headerlink" title="根据盒子滚动的距离来设置绝对定位的top以及数据截取的起始位置"></a>根据盒子滚动的距离来设置绝对定位的top以及数据截取的起始位置</h4><p>给外层盒子绑定scroll事件来确定渲染盒子的定位位置</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;box&quot; :style=&quot;&#123;&#x27;height&#x27;:this.size * this.height + &#x27;px&#x27;&#125;&quot;&gt;</span><br><span class="line">  // 虚拟列表的容器</span><br><span class="line"><span class="addition">+ &lt;div  class=&quot;virtualList&quot; :style=&quot;&#123;&#x27;height&#x27;:this.size * this.height + &#x27;px&#x27;&#125;&quot;  @scroll=&quot;onscroll&quot;&gt; </span></span><br><span class="line">      // 空白盒子 为了撑起滚动条</span><br><span class="line">      &lt;div :style=&quot;&#123;&#x27;height&#x27; : realList.length*height +&#x27;px&#x27;&#125;&quot;&gt;&lt;/div&gt; </span><br><span class="line">      // 可视区域的盒子</span><br><span class="line"><span class="addition">+     &lt;div :style=&quot;&#123;&#x27;top&#x27; : this.scrollTop+&#x27;px&#x27;&#125;&quot; class=&quot;content&quot;&gt;</span></span><br><span class="line">       &lt;div v-for=&quot;(item,i) in renderList&quot; :key=&quot;i&quot; :style=&quot;&#123;&#x27;height&#x27;:height+&#x27;px&#x27;&#125;&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="addition">+  methods: &#123;</span></span><br><span class="line"><span class="addition">+    onscroll() &#123;</span></span><br><span class="line"><span class="addition">+      this.scrollTop = this.$refs.list.scrollTop  // 计算渲染盒子的top定位</span></span><br><span class="line"><span class="addition">+      this.start = this.scrollTop / this.height  // 计算截取数据的起始位置</span></span><br><span class="line"><span class="addition">+    &#125;</span></span><br><span class="line"><span class="addition">+  &#125;,</span></span><br><span class="line">  mounted() &#123;...&#125;,</span><br><span class="line">  computed: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>到此为止一个简单的虚拟列表就完成了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端多数据优化之分片渲染</title>
      <link href="/posts/edb56c4b.html"/>
      <url>/posts/edb56c4b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前端多数据优化之分片渲染"><a href="#前端多数据优化之分片渲染" class="headerlink" title="前端多数据优化之分片渲染"></a>前端多数据优化之分片渲染</h2><p>如果后端给一次你返回10万条数据你会怎么做？ 直接渲染的话很大概率上会导致浏览器卡顿甚至停止运行</p><p><img src="https://image.pengyuhang.com/error.png" alt="服务器崩溃"></p><p>所以就有了分片渲染这一方案</p><h3 id="什么是分片渲染"><a href="#什么是分片渲染" class="headerlink" title="什么是分片渲染"></a>什么是分片渲染</h3><p>分片渲染简单的说就是利用宏任务队列的特点,当上一个宏任务执行完下一个宏任务才会执行,这里可以使用定时器来达到分片渲染的目的</p><h3 id="分片渲染的实现"><a href="#分片渲染的实现" class="headerlink" title="分片渲染的实现"></a>分片渲染的实现</h3><h4 id="准备数据及初始渲染"><a href="#准备数据及初始渲染" class="headerlink" title="准备数据及初始渲染"></a>准备数据及初始渲染</h4><p>采用for循环来达到获取10万条数据的目的，将数据存储在realList中，同时我们准备一个存储分片数据的列表renderList，并通过v-for指令渲染到页面中(<br>当然此时renderList并没有数据，页面也就不会渲染)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item,i) in renderList&quot; :key=&quot;i&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  nane: &#x27;testIndex&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      realList: [],</span><br><span class="line">      renderList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">      this.realList.push(`我是第$&#123;i + 1&#125;条数据`)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="取得渲染数据"><a href="#取得渲染数据" class="headerlink" title="取得渲染数据"></a>取得渲染数据</h4><p>准备一个方法来达到分割原始数据的目的使用数组方法slice来分割数组，并声明一个中间变量list来存储分割后的数据，每次固定分割50个数据(自定)slice方法的两个变量分别设置为this.start和 this.start + this.size截取下一部分时只需要变动start的位置就可以了</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line"><span class="addition">+    start: 0,// 截取的起始位置</span></span><br><span class="line"><span class="addition">+    size: 50,// 每次截取的大小</span></span><br><span class="line">  realList: [],</span><br><span class="line">  renderList: []</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  load() &#123;</span><br><span class="line">    let list = this.realList.slice(this.start, this.start + this.size)</span><br><span class="line">  &#125; </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="递归函数来实现重复截取"><a href="#递归函数来实现重复截取" class="headerlink" title="递归函数来实现重复截取"></a>递归函数来实现重复截取</h4><p>为了达到多次重复分割的目的，我们使用利用递归的方式(即在这个方法中再次调用这个方法)，我们需要判断一下原始数据中是不是还存在我们没有分割到的数据</p><p>在定时器中，向renderList push我们分割好的数组(避免二级数组的出现，需要使用…展开运算符)，当这次分割好的50个数组push完后，我们需要分割下50个数组，把start的值改为this.start + this.size后再次调用我们定义的或者方法</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">load() &#123;</span><br><span class="line">let list = this.realList.slice(this.start, this.start + this.end)</span><br><span class="line">if (list &amp;&amp; list.length &gt; 0) &#123;//当数组存在且又未分割到的数据时再往下执行</span><br><span class="line"><span class="addition">+        setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="addition">+        this.renderList.push(...list)</span></span><br><span class="line"><span class="addition">+        this.start = this.start + this.size</span></span><br><span class="line"><span class="addition">+        this.load()</span></span><br><span class="line"><span class="addition">+       &#125;, 500)</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h4 id="最后在页面加载时去调用这个方法"><a href="#最后在页面加载时去调用这个方法" class="headerlink" title="最后在页面加载时去调用这个方法"></a>最后在页面加载时去调用这个方法</h4><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  for (let i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">    this.realList.push(`我是第$&#123;i + 1&#125;条数据`)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+  this.load()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们再渲染大数据的时候就不会出现浏览器卡死的情况了</p><p>上文介绍的只是最简单的一种分片渲染，只是把全部数据分片后再全部渲染到页面，还有更高级的应用，如：每次只渲染一定的数据，当检测到触底后再加载下一部分，当然也有各种成熟的插件可以实现分片渲染的效果</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
